---
title: "【Sim-To-Real実践】AIはどうやって「バランス感覚」を学ぶのか？遺伝アルゴリズムによる自己進化（実装編）"
emoji: "🧬"
type: "tech"
topics: ["Python", "MachineLearning", "Simulation", "PyBullet", "AI"]
published: true
---

## 1. はじめに：数式で教えるか、経験で学ばせるか

[前回](sim-to-real-01-concept)の記事では、ロボット開発における「仮想世界の器（シミュレーター）」の重要性を解説しました。器が用意できたら、次はその中を走るロボットに「魂（制御ロジック）」を吹き込む番です。

従来のロボット制御（PID制御など）では、エンジニアが「もし3度傾いたら、これくらいの電圧でモーターを回せ」というルールを数学的に計算して記述していました。しかし、今回は違います。**AIに「どうすれば倒れないか」を、何万回もの失敗を通じて自ら発見させる**のです。

今回は、提供したコードの裏側で動いている「AIの脳」と、それを進化させる「遺伝アルゴリズム」の仕組みを深掘りします。

---

## 2. AIの「脳」：超シンプルなニューラルネットワーク

今回、ロボット（倒立振子）の脳として実装しているのは、わずか3層のシンプルな「ニューラルネットワーク」です。



### 脳への入力（センサー情報）
ロボットは、仮想空間から以下の4つのデータを受け取ります。
1.  **車体の角度**: 今、どれくらい傾いているか？
2.  **角速度**: どれくらいの勢いで倒れようとしているか？
3.  **位置**: コースの真ん中からどれくらいズレているか？
4.  **速度**: どれくらいの速さで移動しているか？

### 脳の計算（思考プロセス）
これらの入力に「重み（Weight）」という数値を掛け合わせ、足し算することで、「次にモーターをどれくらい回すか」という命令を決定します。

$$出力 = \text{活性化関数}(\sum (\text{入力} \times \text{重み}))$$

この「重み」こそが、AIの「知識」そのものです。最初はデタラメな数値が入っているため、ロボットは一瞬で転倒します。この**「重み」をどう調整して最適化するかが、学習のすべて**です。

---

## 3. 「遺伝アルゴリズム」：デジタル世界のダーウィニズム

通常のAI学習（ディープラーニング）では「誤差逆伝播法」という難しい数学を使いますが、今回はもっと直感的な **「遺伝アルゴリズム（GA）」** を採用しています。これは、生物の進化（生存競争）をそのままプログラムに落とし込んだ手法です。



### ステップ1：集団の生成（100通りの個性）
まず、ランダムな「重み」を持った脳みそを持つロボットを100体同時に生成します。これらは、いわば「100人の新人ドライバー」です。

### ステップ2：評価（地獄のトライアル）
100体をシミュレーター上で一斉に走らせます。
ここで重要なのが **「適応度（Fitness）」** というスコアです。

```python
# 適応度関数の考え方（実際のコードより簡略化）
fitness = 生存時間 - (傾きの大きさ × 10)
「1秒でも長く立っていた個体が高得点」「フラフラ傾いていた個体は減点」というルールで、順位をつけます。

ステップ3：選択（エリートの選別）
成績の良かった上位10体（エリート）だけを選び出し、残りの90体には「引退（消去）」してもらいます。

ステップ4：交叉と突然変異（次世代の誕生）
生き残った10体の脳みそをもとに、新しい100体の子供を作ります。 ここで、少しだけ 「突然変異（Mutation）」 を加えるのがポイントです。

Python
# 突然変異の実装イメージ
child_weight = parent_weight + np.random.randn() * 0.1 # 少しだけ値を揺らす
この「少しのコピーミス」が、親よりも優れたバランス感覚を持つ個体を生み出すきっかけになります。これを何百世代も繰り返すと、人間には思いつかないような絶妙なバランス制御を行うAIが誕生します。

4. なぜ「AI」を使うのか？（PID制御との違い）
「倒立振子なら、昔ながらのPID制御で十分じゃないか」という意見もあるでしょう。しかし、AI（GA）を使うことには、Sim-To-Realにおいて大きなメリットがあります。

非線形な挙動に強い: ロボットが大きく傾いた時、物理的な挙動は非常に複雑になります。AIはその複雑さをそのまま丸ごと学習できます。

センサーを選ばない: 「何をどう計算するか」を人間が考えなくていいため、センサーの種類を増やしたり変えたりしても、同じアルゴリズムで学習可能です。

未知の環境への適応: シミュレーションと現実の差を「ノイズ」として学習段階で混ぜ込むことで、よりタフな制御が手に入ります。

5. Sim-To-Realの極意：Domain Randomization（ドメイン無作為化）
記事の最後に、シミュレーションで育てたAIを「現実」で動かすための最強のテクニックを紹介します。それが Domain Randomization です。

あえて、シミュレーション環境を「いい加減」にするのです。

床の摩擦係数を、実行するたびに 0.5〜1.5 の間で変える。

ロボットの重さを、±10% 変化させる。

センサーの値に、わざとランダムな砂嵐（ノイズ）を混ぜる。

「完璧なシミュレーション」で育ったAIは、現実の少しのズレでパニックになります。しかし、「最初からデタラメな環境」で育ったAIは、現実のズレを単なる「ノイズの一つ」として受け流すことができます。 「雑草のように育てる」ことが、現実世界で生き抜く強いAIを作るコツなのです。

最後に：あなたのPCで「進化」を体感しよう
今回解説したロジックは、すべて提供したPythonコードの中に組み込まれています。

Bash
# 進化を開始する
python etrobo_ga_sim.py
画面の中で、最初はプルプル震えて倒れていたロボットが、50世代、100世代と重ねるうちに、まるで生き物のようにシャキッと立ち上がる瞬間。それは、まさにデジタルな生命が誕生する感動的な光景です。

Sim-To-Realは、これからのロボット開発の標準スキルです。このコードをベースに、車体の形を変えたり、より難しいコースに挑戦させたりして、あなただけの「最強のAI」を育ててみてください！